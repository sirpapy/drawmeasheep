// This file is generated by omniidl (C++ backend)- omniORB_4_2. Do not edit.
#ifndef __drawMeASheep_hh__
#define __drawMeASheep_hh__

#ifndef __CORBA_H_EXTERNAL_GUARD__
#include <omniORB4/CORBA.h>
#endif

#ifndef  USE_stub_in_nt_dll
# define USE_stub_in_nt_dll_NOT_DEFINED_drawMeASheep
#endif
#ifndef  USE_core_stub_in_nt_dll
# define USE_core_stub_in_nt_dll_NOT_DEFINED_drawMeASheep
#endif
#ifndef  USE_dyn_stub_in_nt_dll
# define USE_dyn_stub_in_nt_dll_NOT_DEFINED_drawMeASheep
#endif






#ifdef USE_stub_in_nt_dll
# ifndef USE_core_stub_in_nt_dll
#  define USE_core_stub_in_nt_dll
# endif
# ifndef USE_dyn_stub_in_nt_dll
#  define USE_dyn_stub_in_nt_dll
# endif
#endif

#ifdef _core_attr
# error "A local CPP macro _core_attr has already been defined."
#else
# ifdef  USE_core_stub_in_nt_dll
#  define _core_attr _OMNIORB_NTDLL_IMPORT
# else
#  define _core_attr
# endif
#endif

#ifdef _dyn_attr
# error "A local CPP macro _dyn_attr has already been defined."
#else
# ifdef  USE_dyn_stub_in_nt_dll
#  define _dyn_attr _OMNIORB_NTDLL_IMPORT
# else
#  define _dyn_attr
# endif
#endif



_CORBA_MODULE drawMeASheep

_CORBA_MODULE_BEG

  _CORBA_MODULE generated

  _CORBA_MODULE_BEG

    _CORBA_MODULE entity

    _CORBA_MODULE_BEG

      struct Point {
        typedef _CORBA_ConstrType_Fix_Var<Point> _var_type;

        
        ::CORBA::Double x;

        ::CORBA::Double y;

      

        void operator>>= (cdrStream &) const;
        void operator<<= (cdrStream &);
      };

      typedef Point::_var_type Point_var;

      typedef Point& Point_out;

      class PointSet_var;

      class PointSet : public _CORBA_Unbounded_Sequence< Point >  {
      public:
        typedef PointSet_var _var_type;
        inline PointSet() {}
        inline PointSet(const PointSet& _s)
          : _CORBA_Unbounded_Sequence< Point > (_s) {}

        inline PointSet(_CORBA_ULong _max)
          : _CORBA_Unbounded_Sequence< Point > (_max) {}
        inline PointSet(_CORBA_ULong _max, _CORBA_ULong _len, Point* _val, _CORBA_Boolean _rel=0)
          : _CORBA_Unbounded_Sequence< Point > (_max, _len, _val, _rel) {}

      

        inline PointSet& operator = (const PointSet& _s) {
          _CORBA_Unbounded_Sequence< Point > ::operator=(_s);
          return *this;
        }
      };

      class PointSet_out;

      class PointSet_var {
      public:
        inline PointSet_var() : _pd_seq(0) {}
        inline PointSet_var(PointSet* _s) : _pd_seq(_s) {}
        inline PointSet_var(const PointSet_var& _s) {
          if (_s._pd_seq)  _pd_seq = new PointSet(*_s._pd_seq);
          else             _pd_seq = 0;
        }
        inline ~PointSet_var() { if (_pd_seq)  delete _pd_seq; }
          
        inline PointSet_var& operator = (PointSet* _s) {
          if (_pd_seq)  delete _pd_seq;
          _pd_seq = _s;
          return *this;
        }
        inline PointSet_var& operator = (const PointSet_var& _s) {
          if (_s._pd_seq) {
            if (!_pd_seq)  _pd_seq = new PointSet;
            *_pd_seq = *_s._pd_seq;
          } else if (_pd_seq) {
            delete _pd_seq;
            _pd_seq = 0;
          }
          return *this;
        }
        inline Point& operator [] (_CORBA_ULong _s) {
          return (*_pd_seq)[_s];
        }

      

        inline PointSet* operator -> () { return _pd_seq; }
        inline const PointSet* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
        inline operator PointSet& () const { return *_pd_seq; }
#else
        inline operator const PointSet& () const { return *_pd_seq; }
        inline operator PointSet& () { return *_pd_seq; }
#endif
          
        inline const PointSet& in() const { return *_pd_seq; }
        inline PointSet&       inout()    { return *_pd_seq; }
        inline PointSet*&      out() {
          if (_pd_seq) { delete _pd_seq; _pd_seq = 0; }
          return _pd_seq;
        }
        inline PointSet* _retn() { PointSet* tmp = _pd_seq; _pd_seq = 0; return tmp; }
          
        friend class PointSet_out;
        
      private:
        PointSet* _pd_seq;
      };

      class PointSet_out {
      public:
        inline PointSet_out(PointSet*& _s) : _data(_s) { _data = 0; }
        inline PointSet_out(PointSet_var& _s)
          : _data(_s._pd_seq) { _s = (PointSet*) 0; }
        inline PointSet_out(const PointSet_out& _s) : _data(_s._data) {}
        inline PointSet_out& operator = (const PointSet_out& _s) {
          _data = _s._data;
          return *this;
        }
        inline PointSet_out& operator = (PointSet* _s) {
          _data = _s;
          return *this;
        }
        inline operator PointSet*&()  { return _data; }
        inline PointSet*& ptr()       { return _data; }
        inline PointSet* operator->() { return _data; }

        inline Point& operator [] (_CORBA_ULong _i) {
          return (*_data)[_i];
        }

      

        PointSet*& _data;

      private:
        PointSet_out();
        PointSet_out& operator=(const PointSet_var&);
      };

#ifndef __drawMeASheep_mgenerated_mentity_mDrawing__
#define __drawMeASheep_mgenerated_mentity_mDrawing__
      class Drawing;
      class _objref_Drawing;
      class _impl_Drawing;
      
      typedef _objref_Drawing* Drawing_ptr;
      typedef Drawing_ptr DrawingRef;

      class Drawing_Helper {
      public:
        typedef Drawing_ptr _ptr_type;

        static _ptr_type _nil();
        static _CORBA_Boolean is_nil(_ptr_type);
        static void release(_ptr_type);
        static void duplicate(_ptr_type);
        static void marshalObjRef(_ptr_type, cdrStream&);
        static _ptr_type unmarshalObjRef(cdrStream&);
      };

      typedef _CORBA_ObjRef_Var<_objref_Drawing, Drawing_Helper> Drawing_var;
      typedef _CORBA_ObjRef_OUT_arg<_objref_Drawing,Drawing_Helper > Drawing_out;

#endif

      // interface Drawing
      class Drawing {
      public:
        // Declarations for this interface type.
        typedef Drawing_ptr _ptr_type;
        typedef Drawing_var _var_type;

        static _ptr_type _duplicate(_ptr_type);
        static _ptr_type _narrow(::CORBA::Object_ptr);
        static _ptr_type _unchecked_narrow(::CORBA::Object_ptr);
        
        static _ptr_type _nil();

        static inline void _marshalObjRef(_ptr_type, cdrStream&);

        static inline _ptr_type _unmarshalObjRef(cdrStream& s) {
          omniObjRef* o = omniObjRef::_unMarshal(_PD_repoId,s);
          if (o)
            return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
          else
            return _nil();
        }

        static inline _ptr_type _fromObjRef(omniObjRef* o) {
          if (o)
            return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
          else
            return _nil();
        }

        static _core_attr const char* _PD_repoId;

        // Other IDL defined within this scope.
        
      };

      class _objref_Drawing :
        public virtual ::CORBA::Object,
        public virtual omniObjRef
      {
      public:
        // IDL operations
        ::CORBA::Double getSurface();
        ::CORBA::Double getPerimeter();
        void translate(::CORBA::Double x);
        void homothetie(::CORBA::Double x);
        void rotate(::CORBA::Double angle);
        void centralSymetric(const ::drawMeASheep::generated::entity::Point& p);
        void axialSymetric(const ::drawMeASheep::generated::entity::Point& p1, const ::drawMeASheep::generated::entity::Point& p2);

        // Constructors
        inline _objref_Drawing()  { _PR_setobj(0); }  // nil
        _objref_Drawing(omniIOR*, omniIdentity*);

      protected:
        virtual ~_objref_Drawing();

        
      private:
        virtual void* _ptrToObjRef(const char*);

        _objref_Drawing(const _objref_Drawing&);
        _objref_Drawing& operator = (const _objref_Drawing&);
        // not implemented

        friend class Drawing;
      };

      class _pof_Drawing : public _OMNI_NS(proxyObjectFactory) {
      public:
        inline _pof_Drawing() : _OMNI_NS(proxyObjectFactory)(Drawing::_PD_repoId) {}
        virtual ~_pof_Drawing();

        virtual omniObjRef* newObjRef(omniIOR*,omniIdentity*);
        virtual _CORBA_Boolean is_a(const char*) const;
      };

      class _impl_Drawing :
        public virtual omniServant
      {
      public:
        virtual ~_impl_Drawing();

        virtual ::CORBA::Double getSurface() = 0;
        virtual ::CORBA::Double getPerimeter() = 0;
        virtual void translate(::CORBA::Double x) = 0;
        virtual void homothetie(::CORBA::Double x) = 0;
        virtual void rotate(::CORBA::Double angle) = 0;
        virtual void centralSymetric(const ::drawMeASheep::generated::entity::Point& p) = 0;
        virtual void axialSymetric(const ::drawMeASheep::generated::entity::Point& p1, const ::drawMeASheep::generated::entity::Point& p2) = 0;
        
      public:  // Really protected, workaround for xlC
        virtual _CORBA_Boolean _dispatch(omniCallHandle&);

      private:
        virtual void* _ptrToInterface(const char*);
        virtual const char* _mostDerivedRepoId();
        
      };


#ifndef __drawMeASheep_mgenerated_mentity_mPolygone__
#define __drawMeASheep_mgenerated_mentity_mPolygone__
      class Polygone;
      class _objref_Polygone;
      class _impl_Polygone;
      
      typedef _objref_Polygone* Polygone_ptr;
      typedef Polygone_ptr PolygoneRef;

      class Polygone_Helper {
      public:
        typedef Polygone_ptr _ptr_type;

        static _ptr_type _nil();
        static _CORBA_Boolean is_nil(_ptr_type);
        static void release(_ptr_type);
        static void duplicate(_ptr_type);
        static void marshalObjRef(_ptr_type, cdrStream&);
        static _ptr_type unmarshalObjRef(cdrStream&);
      };

      typedef _CORBA_ObjRef_Var<_objref_Polygone, Polygone_Helper> Polygone_var;
      typedef _CORBA_ObjRef_OUT_arg<_objref_Polygone,Polygone_Helper > Polygone_out;

#endif

      // interface Polygone
      class Polygone {
      public:
        // Declarations for this interface type.
        typedef Polygone_ptr _ptr_type;
        typedef Polygone_var _var_type;

        static _ptr_type _duplicate(_ptr_type);
        static _ptr_type _narrow(::CORBA::Object_ptr);
        static _ptr_type _unchecked_narrow(::CORBA::Object_ptr);
        
        static _ptr_type _nil();

        static inline void _marshalObjRef(_ptr_type, cdrStream&);

        static inline _ptr_type _unmarshalObjRef(cdrStream& s) {
          omniObjRef* o = omniObjRef::_unMarshal(_PD_repoId,s);
          if (o)
            return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
          else
            return _nil();
        }

        static inline _ptr_type _fromObjRef(omniObjRef* o) {
          if (o)
            return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
          else
            return _nil();
        }

        static _core_attr const char* _PD_repoId;

        // Other IDL defined within this scope.
        
      };

      class _objref_Polygone :
        public virtual _objref_Drawing
      {
      public:
        // IDL operations
        PointSet* points();

        // Constructors
        inline _objref_Polygone()  { _PR_setobj(0); }  // nil
        _objref_Polygone(omniIOR*, omniIdentity*);

      protected:
        virtual ~_objref_Polygone();

        
      private:
        virtual void* _ptrToObjRef(const char*);

        _objref_Polygone(const _objref_Polygone&);
        _objref_Polygone& operator = (const _objref_Polygone&);
        // not implemented

        friend class Polygone;
      };

      class _pof_Polygone : public _OMNI_NS(proxyObjectFactory) {
      public:
        inline _pof_Polygone() : _OMNI_NS(proxyObjectFactory)(Polygone::_PD_repoId) {}
        virtual ~_pof_Polygone();

        virtual omniObjRef* newObjRef(omniIOR*,omniIdentity*);
        virtual _CORBA_Boolean is_a(const char*) const;
      };

      class _impl_Polygone :
        public virtual _impl_Drawing
      {
      public:
        virtual ~_impl_Polygone();

        virtual PointSet* points() = 0;
        
      public:  // Really protected, workaround for xlC
        virtual _CORBA_Boolean _dispatch(omniCallHandle&);

      private:
        virtual void* _ptrToInterface(const char*);
        virtual const char* _mostDerivedRepoId();
        
      };


#ifndef __drawMeASheep_mgenerated_mentity_mLine__
#define __drawMeASheep_mgenerated_mentity_mLine__
      class Line;
      class _objref_Line;
      class _impl_Line;
      
      typedef _objref_Line* Line_ptr;
      typedef Line_ptr LineRef;

      class Line_Helper {
      public:
        typedef Line_ptr _ptr_type;

        static _ptr_type _nil();
        static _CORBA_Boolean is_nil(_ptr_type);
        static void release(_ptr_type);
        static void duplicate(_ptr_type);
        static void marshalObjRef(_ptr_type, cdrStream&);
        static _ptr_type unmarshalObjRef(cdrStream&);
      };

      typedef _CORBA_ObjRef_Var<_objref_Line, Line_Helper> Line_var;
      typedef _CORBA_ObjRef_OUT_arg<_objref_Line,Line_Helper > Line_out;

#endif

      // interface Line
      class Line {
      public:
        // Declarations for this interface type.
        typedef Line_ptr _ptr_type;
        typedef Line_var _var_type;

        static _ptr_type _duplicate(_ptr_type);
        static _ptr_type _narrow(::CORBA::Object_ptr);
        static _ptr_type _unchecked_narrow(::CORBA::Object_ptr);
        
        static _ptr_type _nil();

        static inline void _marshalObjRef(_ptr_type, cdrStream&);

        static inline _ptr_type _unmarshalObjRef(cdrStream& s) {
          omniObjRef* o = omniObjRef::_unMarshal(_PD_repoId,s);
          if (o)
            return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
          else
            return _nil();
        }

        static inline _ptr_type _fromObjRef(omniObjRef* o) {
          if (o)
            return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
          else
            return _nil();
        }

        static _core_attr const char* _PD_repoId;

        // Other IDL defined within this scope.
        
      };

      class _objref_Line :
        public virtual _objref_Drawing
      {
      public:
        // IDL operations
        Point a();
        Point b();

        // Constructors
        inline _objref_Line()  { _PR_setobj(0); }  // nil
        _objref_Line(omniIOR*, omniIdentity*);

      protected:
        virtual ~_objref_Line();

        
      private:
        virtual void* _ptrToObjRef(const char*);

        _objref_Line(const _objref_Line&);
        _objref_Line& operator = (const _objref_Line&);
        // not implemented

        friend class Line;
      };

      class _pof_Line : public _OMNI_NS(proxyObjectFactory) {
      public:
        inline _pof_Line() : _OMNI_NS(proxyObjectFactory)(Line::_PD_repoId) {}
        virtual ~_pof_Line();

        virtual omniObjRef* newObjRef(omniIOR*,omniIdentity*);
        virtual _CORBA_Boolean is_a(const char*) const;
      };

      class _impl_Line :
        public virtual _impl_Drawing
      {
      public:
        virtual ~_impl_Line();

        virtual Point a() = 0;
        virtual Point b() = 0;
        
      public:  // Really protected, workaround for xlC
        virtual _CORBA_Boolean _dispatch(omniCallHandle&);

      private:
        virtual void* _ptrToInterface(const char*);
        virtual const char* _mostDerivedRepoId();
        
      };


#ifndef __drawMeASheep_mgenerated_mentity_mCercle__
#define __drawMeASheep_mgenerated_mentity_mCercle__
      class Cercle;
      class _objref_Cercle;
      class _impl_Cercle;
      
      typedef _objref_Cercle* Cercle_ptr;
      typedef Cercle_ptr CercleRef;

      class Cercle_Helper {
      public:
        typedef Cercle_ptr _ptr_type;

        static _ptr_type _nil();
        static _CORBA_Boolean is_nil(_ptr_type);
        static void release(_ptr_type);
        static void duplicate(_ptr_type);
        static void marshalObjRef(_ptr_type, cdrStream&);
        static _ptr_type unmarshalObjRef(cdrStream&);
      };

      typedef _CORBA_ObjRef_Var<_objref_Cercle, Cercle_Helper> Cercle_var;
      typedef _CORBA_ObjRef_OUT_arg<_objref_Cercle,Cercle_Helper > Cercle_out;

#endif

      // interface Cercle
      class Cercle {
      public:
        // Declarations for this interface type.
        typedef Cercle_ptr _ptr_type;
        typedef Cercle_var _var_type;

        static _ptr_type _duplicate(_ptr_type);
        static _ptr_type _narrow(::CORBA::Object_ptr);
        static _ptr_type _unchecked_narrow(::CORBA::Object_ptr);
        
        static _ptr_type _nil();

        static inline void _marshalObjRef(_ptr_type, cdrStream&);

        static inline _ptr_type _unmarshalObjRef(cdrStream& s) {
          omniObjRef* o = omniObjRef::_unMarshal(_PD_repoId,s);
          if (o)
            return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
          else
            return _nil();
        }

        static inline _ptr_type _fromObjRef(omniObjRef* o) {
          if (o)
            return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
          else
            return _nil();
        }

        static _core_attr const char* _PD_repoId;

        // Other IDL defined within this scope.
        
      };

      class _objref_Cercle :
        public virtual _objref_Drawing
      {
      public:
        // IDL operations
        ::CORBA::Double rayon();

        // Constructors
        inline _objref_Cercle()  { _PR_setobj(0); }  // nil
        _objref_Cercle(omniIOR*, omniIdentity*);

      protected:
        virtual ~_objref_Cercle();

        
      private:
        virtual void* _ptrToObjRef(const char*);

        _objref_Cercle(const _objref_Cercle&);
        _objref_Cercle& operator = (const _objref_Cercle&);
        // not implemented

        friend class Cercle;
      };

      class _pof_Cercle : public _OMNI_NS(proxyObjectFactory) {
      public:
        inline _pof_Cercle() : _OMNI_NS(proxyObjectFactory)(Cercle::_PD_repoId) {}
        virtual ~_pof_Cercle();

        virtual omniObjRef* newObjRef(omniIOR*,omniIdentity*);
        virtual _CORBA_Boolean is_a(const char*) const;
      };

      class _impl_Cercle :
        public virtual _impl_Drawing
      {
      public:
        virtual ~_impl_Cercle();

        virtual ::CORBA::Double rayon() = 0;
        
      public:  // Really protected, workaround for xlC
        virtual _CORBA_Boolean _dispatch(omniCallHandle&);

      private:
        virtual void* _ptrToInterface(const char*);
        virtual const char* _mostDerivedRepoId();
        
      };


#ifndef __drawMeASheep_mgenerated_mentity_mEllipse__
#define __drawMeASheep_mgenerated_mentity_mEllipse__
      class Ellipse;
      class _objref_Ellipse;
      class _impl_Ellipse;
      
      typedef _objref_Ellipse* Ellipse_ptr;
      typedef Ellipse_ptr EllipseRef;

      class Ellipse_Helper {
      public:
        typedef Ellipse_ptr _ptr_type;

        static _ptr_type _nil();
        static _CORBA_Boolean is_nil(_ptr_type);
        static void release(_ptr_type);
        static void duplicate(_ptr_type);
        static void marshalObjRef(_ptr_type, cdrStream&);
        static _ptr_type unmarshalObjRef(cdrStream&);
      };

      typedef _CORBA_ObjRef_Var<_objref_Ellipse, Ellipse_Helper> Ellipse_var;
      typedef _CORBA_ObjRef_OUT_arg<_objref_Ellipse,Ellipse_Helper > Ellipse_out;

#endif

      // interface Ellipse
      class Ellipse {
      public:
        // Declarations for this interface type.
        typedef Ellipse_ptr _ptr_type;
        typedef Ellipse_var _var_type;

        static _ptr_type _duplicate(_ptr_type);
        static _ptr_type _narrow(::CORBA::Object_ptr);
        static _ptr_type _unchecked_narrow(::CORBA::Object_ptr);
        
        static _ptr_type _nil();

        static inline void _marshalObjRef(_ptr_type, cdrStream&);

        static inline _ptr_type _unmarshalObjRef(cdrStream& s) {
          omniObjRef* o = omniObjRef::_unMarshal(_PD_repoId,s);
          if (o)
            return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
          else
            return _nil();
        }

        static inline _ptr_type _fromObjRef(omniObjRef* o) {
          if (o)
            return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
          else
            return _nil();
        }

        static _core_attr const char* _PD_repoId;

        // Other IDL defined within this scope.
        
      };

      class _objref_Ellipse :
        public virtual _objref_Drawing
      {
      public:
        // IDL operations
        PointSet* points();

        // Constructors
        inline _objref_Ellipse()  { _PR_setobj(0); }  // nil
        _objref_Ellipse(omniIOR*, omniIdentity*);

      protected:
        virtual ~_objref_Ellipse();

        
      private:
        virtual void* _ptrToObjRef(const char*);

        _objref_Ellipse(const _objref_Ellipse&);
        _objref_Ellipse& operator = (const _objref_Ellipse&);
        // not implemented

        friend class Ellipse;
      };

      class _pof_Ellipse : public _OMNI_NS(proxyObjectFactory) {
      public:
        inline _pof_Ellipse() : _OMNI_NS(proxyObjectFactory)(Ellipse::_PD_repoId) {}
        virtual ~_pof_Ellipse();

        virtual omniObjRef* newObjRef(omniIOR*,omniIdentity*);
        virtual _CORBA_Boolean is_a(const char*) const;
      };

      class _impl_Ellipse :
        public virtual _impl_Drawing
      {
      public:
        virtual ~_impl_Ellipse();

        virtual PointSet* points() = 0;
        
      public:  // Really protected, workaround for xlC
        virtual _CORBA_Boolean _dispatch(omniCallHandle&);

      private:
        virtual void* _ptrToInterface(const char*);
        virtual const char* _mostDerivedRepoId();
        
      };


      class DrawingSet_var;

      class DrawingSet : public _CORBA_Unbounded_Sequence_ObjRef< _objref_Drawing, _CORBA_ObjRef_Element< _objref_Drawing, Drawing_Helper> , Drawing_Helper >  {
      public:
        typedef DrawingSet_var _var_type;
        inline DrawingSet() {}
        inline DrawingSet(const DrawingSet& _s)
          : _CORBA_Unbounded_Sequence_ObjRef< _objref_Drawing, _CORBA_ObjRef_Element< _objref_Drawing, Drawing_Helper> , Drawing_Helper > (_s) {}

        inline DrawingSet(_CORBA_ULong _max)
          : _CORBA_Unbounded_Sequence_ObjRef< _objref_Drawing, _CORBA_ObjRef_Element< _objref_Drawing, Drawing_Helper> , Drawing_Helper > (_max) {}
        inline DrawingSet(_CORBA_ULong _max, _CORBA_ULong _len, Drawing_ptr* _val, _CORBA_Boolean _rel=0)
          : _CORBA_Unbounded_Sequence_ObjRef< _objref_Drawing, _CORBA_ObjRef_Element< _objref_Drawing, Drawing_Helper> , Drawing_Helper > (_max, _len, _val, _rel) {}

      

        inline DrawingSet& operator = (const DrawingSet& _s) {
          _CORBA_Unbounded_Sequence_ObjRef< _objref_Drawing, _CORBA_ObjRef_Element< _objref_Drawing, Drawing_Helper> , Drawing_Helper > ::operator=(_s);
          return *this;
        }
      };

      class DrawingSet_out;

      class DrawingSet_var {
      public:
        inline DrawingSet_var() : _pd_seq(0) {}
        inline DrawingSet_var(DrawingSet* _s) : _pd_seq(_s) {}
        inline DrawingSet_var(const DrawingSet_var& _s) {
          if (_s._pd_seq)  _pd_seq = new DrawingSet(*_s._pd_seq);
          else             _pd_seq = 0;
        }
        inline ~DrawingSet_var() { if (_pd_seq)  delete _pd_seq; }
          
        inline DrawingSet_var& operator = (DrawingSet* _s) {
          if (_pd_seq)  delete _pd_seq;
          _pd_seq = _s;
          return *this;
        }
        inline DrawingSet_var& operator = (const DrawingSet_var& _s) {
          if (_s._pd_seq) {
            if (!_pd_seq)  _pd_seq = new DrawingSet;
            *_pd_seq = *_s._pd_seq;
          } else if (_pd_seq) {
            delete _pd_seq;
            _pd_seq = 0;
          }
          return *this;
        }
        inline _CORBA_ObjRef_Element< _objref_Drawing, Drawing_Helper>  operator [] (_CORBA_ULong _s) {
          return (*_pd_seq)[_s];
        }

      

        inline DrawingSet* operator -> () { return _pd_seq; }
        inline const DrawingSet* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
        inline operator DrawingSet& () const { return *_pd_seq; }
#else
        inline operator const DrawingSet& () const { return *_pd_seq; }
        inline operator DrawingSet& () { return *_pd_seq; }
#endif
          
        inline const DrawingSet& in() const { return *_pd_seq; }
        inline DrawingSet&       inout()    { return *_pd_seq; }
        inline DrawingSet*&      out() {
          if (_pd_seq) { delete _pd_seq; _pd_seq = 0; }
          return _pd_seq;
        }
        inline DrawingSet* _retn() { DrawingSet* tmp = _pd_seq; _pd_seq = 0; return tmp; }
          
        friend class DrawingSet_out;
        
      private:
        DrawingSet* _pd_seq;
      };

      class DrawingSet_out {
      public:
        inline DrawingSet_out(DrawingSet*& _s) : _data(_s) { _data = 0; }
        inline DrawingSet_out(DrawingSet_var& _s)
          : _data(_s._pd_seq) { _s = (DrawingSet*) 0; }
        inline DrawingSet_out(const DrawingSet_out& _s) : _data(_s._data) {}
        inline DrawingSet_out& operator = (const DrawingSet_out& _s) {
          _data = _s._data;
          return *this;
        }
        inline DrawingSet_out& operator = (DrawingSet* _s) {
          _data = _s;
          return *this;
        }
        inline operator DrawingSet*&()  { return _data; }
        inline DrawingSet*& ptr()       { return _data; }
        inline DrawingSet* operator->() { return _data; }

        inline _CORBA_ObjRef_Element< _objref_Drawing, Drawing_Helper>  operator [] (_CORBA_ULong _i) {
          return (*_data)[_i];
        }

      

        DrawingSet*& _data;

      private:
        DrawingSet_out();
        DrawingSet_out& operator=(const DrawingSet_var&);
      };

      class DrawingMap_var;

      class DrawingMap : public _CORBA_Unbounded_Sequence_ObjRef< _objref_Drawing, _CORBA_ObjRef_Element< _objref_Drawing, Drawing_Helper> , Drawing_Helper >  {
      public:
        typedef DrawingMap_var _var_type;
        inline DrawingMap() {}
        inline DrawingMap(const DrawingMap& _s)
          : _CORBA_Unbounded_Sequence_ObjRef< _objref_Drawing, _CORBA_ObjRef_Element< _objref_Drawing, Drawing_Helper> , Drawing_Helper > (_s) {}

        inline DrawingMap(_CORBA_ULong _max)
          : _CORBA_Unbounded_Sequence_ObjRef< _objref_Drawing, _CORBA_ObjRef_Element< _objref_Drawing, Drawing_Helper> , Drawing_Helper > (_max) {}
        inline DrawingMap(_CORBA_ULong _max, _CORBA_ULong _len, Drawing_ptr* _val, _CORBA_Boolean _rel=0)
          : _CORBA_Unbounded_Sequence_ObjRef< _objref_Drawing, _CORBA_ObjRef_Element< _objref_Drawing, Drawing_Helper> , Drawing_Helper > (_max, _len, _val, _rel) {}

      

        inline DrawingMap& operator = (const DrawingMap& _s) {
          _CORBA_Unbounded_Sequence_ObjRef< _objref_Drawing, _CORBA_ObjRef_Element< _objref_Drawing, Drawing_Helper> , Drawing_Helper > ::operator=(_s);
          return *this;
        }
      };

      class DrawingMap_out;

      class DrawingMap_var {
      public:
        inline DrawingMap_var() : _pd_seq(0) {}
        inline DrawingMap_var(DrawingMap* _s) : _pd_seq(_s) {}
        inline DrawingMap_var(const DrawingMap_var& _s) {
          if (_s._pd_seq)  _pd_seq = new DrawingMap(*_s._pd_seq);
          else             _pd_seq = 0;
        }
        inline ~DrawingMap_var() { if (_pd_seq)  delete _pd_seq; }
          
        inline DrawingMap_var& operator = (DrawingMap* _s) {
          if (_pd_seq)  delete _pd_seq;
          _pd_seq = _s;
          return *this;
        }
        inline DrawingMap_var& operator = (const DrawingMap_var& _s) {
          if (_s._pd_seq) {
            if (!_pd_seq)  _pd_seq = new DrawingMap;
            *_pd_seq = *_s._pd_seq;
          } else if (_pd_seq) {
            delete _pd_seq;
            _pd_seq = 0;
          }
          return *this;
        }
        inline _CORBA_ObjRef_Element< _objref_Drawing, Drawing_Helper>  operator [] (_CORBA_ULong _s) {
          return (*_pd_seq)[_s];
        }

      

        inline DrawingMap* operator -> () { return _pd_seq; }
        inline const DrawingMap* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
        inline operator DrawingMap& () const { return *_pd_seq; }
#else
        inline operator const DrawingMap& () const { return *_pd_seq; }
        inline operator DrawingMap& () { return *_pd_seq; }
#endif
          
        inline const DrawingMap& in() const { return *_pd_seq; }
        inline DrawingMap&       inout()    { return *_pd_seq; }
        inline DrawingMap*&      out() {
          if (_pd_seq) { delete _pd_seq; _pd_seq = 0; }
          return _pd_seq;
        }
        inline DrawingMap* _retn() { DrawingMap* tmp = _pd_seq; _pd_seq = 0; return tmp; }
          
        friend class DrawingMap_out;
        
      private:
        DrawingMap* _pd_seq;
      };

      class DrawingMap_out {
      public:
        inline DrawingMap_out(DrawingMap*& _s) : _data(_s) { _data = 0; }
        inline DrawingMap_out(DrawingMap_var& _s)
          : _data(_s._pd_seq) { _s = (DrawingMap*) 0; }
        inline DrawingMap_out(const DrawingMap_out& _s) : _data(_s._data) {}
        inline DrawingMap_out& operator = (const DrawingMap_out& _s) {
          _data = _s._data;
          return *this;
        }
        inline DrawingMap_out& operator = (DrawingMap* _s) {
          _data = _s;
          return *this;
        }
        inline operator DrawingMap*&()  { return _data; }
        inline DrawingMap*& ptr()       { return _data; }
        inline DrawingMap* operator->() { return _data; }

        inline _CORBA_ObjRef_Element< _objref_Drawing, Drawing_Helper>  operator [] (_CORBA_ULong _i) {
          return (*_data)[_i];
        }

      

        DrawingMap*& _data;

      private:
        DrawingMap_out();
        DrawingMap_out& operator=(const DrawingMap_var&);
      };

#ifndef __drawMeASheep_mgenerated_mentity_mDrawingGroup__
#define __drawMeASheep_mgenerated_mentity_mDrawingGroup__
      class DrawingGroup;
      class _objref_DrawingGroup;
      class _impl_DrawingGroup;
      
      typedef _objref_DrawingGroup* DrawingGroup_ptr;
      typedef DrawingGroup_ptr DrawingGroupRef;

      class DrawingGroup_Helper {
      public:
        typedef DrawingGroup_ptr _ptr_type;

        static _ptr_type _nil();
        static _CORBA_Boolean is_nil(_ptr_type);
        static void release(_ptr_type);
        static void duplicate(_ptr_type);
        static void marshalObjRef(_ptr_type, cdrStream&);
        static _ptr_type unmarshalObjRef(cdrStream&);
      };

      typedef _CORBA_ObjRef_Var<_objref_DrawingGroup, DrawingGroup_Helper> DrawingGroup_var;
      typedef _CORBA_ObjRef_OUT_arg<_objref_DrawingGroup,DrawingGroup_Helper > DrawingGroup_out;

#endif

      // interface DrawingGroup
      class DrawingGroup {
      public:
        // Declarations for this interface type.
        typedef DrawingGroup_ptr _ptr_type;
        typedef DrawingGroup_var _var_type;

        static _ptr_type _duplicate(_ptr_type);
        static _ptr_type _narrow(::CORBA::Object_ptr);
        static _ptr_type _unchecked_narrow(::CORBA::Object_ptr);
        
        static _ptr_type _nil();

        static inline void _marshalObjRef(_ptr_type, cdrStream&);

        static inline _ptr_type _unmarshalObjRef(cdrStream& s) {
          omniObjRef* o = omniObjRef::_unMarshal(_PD_repoId,s);
          if (o)
            return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
          else
            return _nil();
        }

        static inline _ptr_type _fromObjRef(omniObjRef* o) {
          if (o)
            return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
          else
            return _nil();
        }

        static _core_attr const char* _PD_repoId;

        // Other IDL defined within this scope.
        
      };

      class _objref_DrawingGroup :
        public virtual _objref_Drawing
      {
      public:
        // IDL operations
        DrawingSet* Drawings();

        // Constructors
        inline _objref_DrawingGroup()  { _PR_setobj(0); }  // nil
        _objref_DrawingGroup(omniIOR*, omniIdentity*);

      protected:
        virtual ~_objref_DrawingGroup();

        
      private:
        virtual void* _ptrToObjRef(const char*);

        _objref_DrawingGroup(const _objref_DrawingGroup&);
        _objref_DrawingGroup& operator = (const _objref_DrawingGroup&);
        // not implemented

        friend class DrawingGroup;
      };

      class _pof_DrawingGroup : public _OMNI_NS(proxyObjectFactory) {
      public:
        inline _pof_DrawingGroup() : _OMNI_NS(proxyObjectFactory)(DrawingGroup::_PD_repoId) {}
        virtual ~_pof_DrawingGroup();

        virtual omniObjRef* newObjRef(omniIOR*,omniIdentity*);
        virtual _CORBA_Boolean is_a(const char*) const;
      };

      class _impl_DrawingGroup :
        public virtual _impl_Drawing
      {
      public:
        virtual ~_impl_DrawingGroup();

        virtual DrawingSet* Drawings() = 0;
        
      public:  // Really protected, workaround for xlC
        virtual _CORBA_Boolean _dispatch(omniCallHandle&);

      private:
        virtual void* _ptrToInterface(const char*);
        virtual const char* _mostDerivedRepoId();
        
      };


    _CORBA_MODULE_END

    _CORBA_MODULE manager

    _CORBA_MODULE_BEG

#ifndef __drawMeASheep_mgenerated_mmanager_mDrawingManager__
#define __drawMeASheep_mgenerated_mmanager_mDrawingManager__
      class DrawingManager;
      class _objref_DrawingManager;
      class _impl_DrawingManager;
      
      typedef _objref_DrawingManager* DrawingManager_ptr;
      typedef DrawingManager_ptr DrawingManagerRef;

      class DrawingManager_Helper {
      public:
        typedef DrawingManager_ptr _ptr_type;

        static _ptr_type _nil();
        static _CORBA_Boolean is_nil(_ptr_type);
        static void release(_ptr_type);
        static void duplicate(_ptr_type);
        static void marshalObjRef(_ptr_type, cdrStream&);
        static _ptr_type unmarshalObjRef(cdrStream&);
      };

      typedef _CORBA_ObjRef_Var<_objref_DrawingManager, DrawingManager_Helper> DrawingManager_var;
      typedef _CORBA_ObjRef_OUT_arg<_objref_DrawingManager,DrawingManager_Helper > DrawingManager_out;

#endif

      // interface DrawingManager
      class DrawingManager {
      public:
        // Declarations for this interface type.
        typedef DrawingManager_ptr _ptr_type;
        typedef DrawingManager_var _var_type;

        static _ptr_type _duplicate(_ptr_type);
        static _ptr_type _narrow(::CORBA::Object_ptr);
        static _ptr_type _unchecked_narrow(::CORBA::Object_ptr);
        
        static _ptr_type _nil();

        static inline void _marshalObjRef(_ptr_type, cdrStream&);

        static inline _ptr_type _unmarshalObjRef(cdrStream& s) {
          omniObjRef* o = omniObjRef::_unMarshal(_PD_repoId,s);
          if (o)
            return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
          else
            return _nil();
        }

        static inline _ptr_type _fromObjRef(omniObjRef* o) {
          if (o)
            return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
          else
            return _nil();
        }

        static _core_attr const char* _PD_repoId;

        // Other IDL defined within this scope.
        
      };

      class _objref_DrawingManager :
        public virtual ::CORBA::Object,
        public virtual omniObjRef
      {
      public:
        // IDL operations
        entity::DrawingMap* map();
        ::CORBA::Any* createDrawing(const char* name, const ::drawMeASheep::generated::entity::PointSet& points, ::CORBA::Double rayon);
        ::CORBA::Boolean add(const ::CORBA::Any& a);
        ::CORBA::Boolean isFull();
        ::CORBA::Double getAvailableSurface();

        // Constructors
        inline _objref_DrawingManager()  { _PR_setobj(0); }  // nil
        _objref_DrawingManager(omniIOR*, omniIdentity*);

      protected:
        virtual ~_objref_DrawingManager();

        
      private:
        virtual void* _ptrToObjRef(const char*);

        _objref_DrawingManager(const _objref_DrawingManager&);
        _objref_DrawingManager& operator = (const _objref_DrawingManager&);
        // not implemented

        friend class DrawingManager;
      };

      class _pof_DrawingManager : public _OMNI_NS(proxyObjectFactory) {
      public:
        inline _pof_DrawingManager() : _OMNI_NS(proxyObjectFactory)(DrawingManager::_PD_repoId) {}
        virtual ~_pof_DrawingManager();

        virtual omniObjRef* newObjRef(omniIOR*,omniIdentity*);
        virtual _CORBA_Boolean is_a(const char*) const;
      };

      class _impl_DrawingManager :
        public virtual omniServant
      {
      public:
        virtual ~_impl_DrawingManager();

        virtual entity::DrawingMap* map() = 0;
        virtual ::CORBA::Any* createDrawing(const char* name, const ::drawMeASheep::generated::entity::PointSet& points, ::CORBA::Double rayon) = 0;
        virtual ::CORBA::Boolean add(const ::CORBA::Any& a) = 0;
        virtual ::CORBA::Boolean isFull() = 0;
        virtual ::CORBA::Double getAvailableSurface() = 0;
        
      public:  // Really protected, workaround for xlC
        virtual _CORBA_Boolean _dispatch(omniCallHandle&);

      private:
        virtual void* _ptrToInterface(const char*);
        virtual const char* _mostDerivedRepoId();
        
      };


    _CORBA_MODULE_END

  _CORBA_MODULE_END

_CORBA_MODULE_END



_CORBA_MODULE POA_drawMeASheep
_CORBA_MODULE_BEG

  _CORBA_MODULE generated
  _CORBA_MODULE_BEG

    _CORBA_MODULE entity
    _CORBA_MODULE_BEG

      class Drawing :
        public virtual drawMeASheep::generated::entity::_impl_Drawing,
        public virtual ::PortableServer::ServantBase
      {
      public:
        virtual ~Drawing();

        inline ::drawMeASheep::generated::entity::Drawing_ptr _this() {
          return (::drawMeASheep::generated::entity::Drawing_ptr) _do_this(::drawMeASheep::generated::entity::Drawing::_PD_repoId);
        }
      };

      class Polygone :
        public virtual drawMeASheep::generated::entity::_impl_Polygone,
        public virtual Drawing
      {
      public:
        virtual ~Polygone();

        inline ::drawMeASheep::generated::entity::Polygone_ptr _this() {
          return (::drawMeASheep::generated::entity::Polygone_ptr) _do_this(::drawMeASheep::generated::entity::Polygone::_PD_repoId);
        }
      };

      class Line :
        public virtual drawMeASheep::generated::entity::_impl_Line,
        public virtual Drawing
      {
      public:
        virtual ~Line();

        inline ::drawMeASheep::generated::entity::Line_ptr _this() {
          return (::drawMeASheep::generated::entity::Line_ptr) _do_this(::drawMeASheep::generated::entity::Line::_PD_repoId);
        }
      };

      class Cercle :
        public virtual drawMeASheep::generated::entity::_impl_Cercle,
        public virtual Drawing
      {
      public:
        virtual ~Cercle();

        inline ::drawMeASheep::generated::entity::Cercle_ptr _this() {
          return (::drawMeASheep::generated::entity::Cercle_ptr) _do_this(::drawMeASheep::generated::entity::Cercle::_PD_repoId);
        }
      };

      class Ellipse :
        public virtual drawMeASheep::generated::entity::_impl_Ellipse,
        public virtual Drawing
      {
      public:
        virtual ~Ellipse();

        inline ::drawMeASheep::generated::entity::Ellipse_ptr _this() {
          return (::drawMeASheep::generated::entity::Ellipse_ptr) _do_this(::drawMeASheep::generated::entity::Ellipse::_PD_repoId);
        }
      };

      class DrawingGroup :
        public virtual drawMeASheep::generated::entity::_impl_DrawingGroup,
        public virtual Drawing
      {
      public:
        virtual ~DrawingGroup();

        inline ::drawMeASheep::generated::entity::DrawingGroup_ptr _this() {
          return (::drawMeASheep::generated::entity::DrawingGroup_ptr) _do_this(::drawMeASheep::generated::entity::DrawingGroup::_PD_repoId);
        }
      };

    _CORBA_MODULE_END

    _CORBA_MODULE manager
    _CORBA_MODULE_BEG

      class DrawingManager :
        public virtual drawMeASheep::generated::manager::_impl_DrawingManager,
        public virtual ::PortableServer::ServantBase
      {
      public:
        virtual ~DrawingManager();

        inline ::drawMeASheep::generated::manager::DrawingManager_ptr _this() {
          return (::drawMeASheep::generated::manager::DrawingManager_ptr) _do_this(::drawMeASheep::generated::manager::DrawingManager::_PD_repoId);
        }
      };

    _CORBA_MODULE_END

  _CORBA_MODULE_END

_CORBA_MODULE_END



_CORBA_MODULE OBV_drawMeASheep
_CORBA_MODULE_BEG

  _CORBA_MODULE generated
  _CORBA_MODULE_BEG

    _CORBA_MODULE entity
    _CORBA_MODULE_BEG

    _CORBA_MODULE_END

    _CORBA_MODULE manager
    _CORBA_MODULE_BEG

    _CORBA_MODULE_END

  _CORBA_MODULE_END

_CORBA_MODULE_END





#undef _core_attr
#undef _dyn_attr



inline void
drawMeASheep::generated::entity::Drawing::_marshalObjRef(::drawMeASheep::generated::entity::Drawing_ptr obj, cdrStream& s) {
  omniObjRef::_marshal(obj->_PR_getobj(),s);
}

inline void
drawMeASheep::generated::entity::Polygone::_marshalObjRef(::drawMeASheep::generated::entity::Polygone_ptr obj, cdrStream& s) {
  omniObjRef::_marshal(obj->_PR_getobj(),s);
}

inline void
drawMeASheep::generated::entity::Line::_marshalObjRef(::drawMeASheep::generated::entity::Line_ptr obj, cdrStream& s) {
  omniObjRef::_marshal(obj->_PR_getobj(),s);
}

inline void
drawMeASheep::generated::entity::Cercle::_marshalObjRef(::drawMeASheep::generated::entity::Cercle_ptr obj, cdrStream& s) {
  omniObjRef::_marshal(obj->_PR_getobj(),s);
}

inline void
drawMeASheep::generated::entity::Ellipse::_marshalObjRef(::drawMeASheep::generated::entity::Ellipse_ptr obj, cdrStream& s) {
  omniObjRef::_marshal(obj->_PR_getobj(),s);
}

inline void
drawMeASheep::generated::entity::DrawingGroup::_marshalObjRef(::drawMeASheep::generated::entity::DrawingGroup_ptr obj, cdrStream& s) {
  omniObjRef::_marshal(obj->_PR_getobj(),s);
}

inline void
drawMeASheep::generated::manager::DrawingManager::_marshalObjRef(::drawMeASheep::generated::manager::DrawingManager_ptr obj, cdrStream& s) {
  omniObjRef::_marshal(obj->_PR_getobj(),s);
}



#ifdef   USE_stub_in_nt_dll_NOT_DEFINED_drawMeASheep
# undef  USE_stub_in_nt_dll
# undef  USE_stub_in_nt_dll_NOT_DEFINED_drawMeASheep
#endif
#ifdef   USE_core_stub_in_nt_dll_NOT_DEFINED_drawMeASheep
# undef  USE_core_stub_in_nt_dll
# undef  USE_core_stub_in_nt_dll_NOT_DEFINED_drawMeASheep
#endif
#ifdef   USE_dyn_stub_in_nt_dll_NOT_DEFINED_drawMeASheep
# undef  USE_dyn_stub_in_nt_dll
# undef  USE_dyn_stub_in_nt_dll_NOT_DEFINED_drawMeASheep
#endif

#endif  // __drawMeASheep_hh__

